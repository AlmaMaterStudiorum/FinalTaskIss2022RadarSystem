<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}

div.filledbyprovider{
	background-color: #00CCAA;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
img.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 80%;
}
</style>
    
<head>
   
<title>FinalTask2022</title></head>
    
<body>
<div id="top">
<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
<div class="remark">
Our motto:<br/>   <k>there is no code without a project, no project
without problem analysis and no problem without requirements</k>.
 </div>
 
<h2>Requirements</h2>

 
<div class="remark">
Requirements are defined in RadarSystem.html
</div>

 

<h2>Requirement analysis</h2>
<div class="remark">
<ks>MAIN GOALS</ks>: 
<ol>
<li>clarify the <k>meaning</k> of the <i>names</i> and of the <i>verbs</i> included in the requirement text given by the customer</li>
<li>(informally) define a first set of <k>functional TestPlans</k></li>
<!-- <li>setup first working prototype </li> -->
</ol>
</div>

<div class="filledbyprovider">
<ks>DOMAIN GLOSSARY</ks>: 
<ol>

<li><ks>radarGui</ks>: software component that show distance from Sonar.</li>
<li><ks>Sonar</ks>: hardware component provided by client , detect distance from Sonar , name of the model is ``HC-SR04`` , the distance is read by software entity.</li>
<li><ks>RadarDisplay</ks>: GUI for the radarGui , it is commanded by sending coordinates.</li>
<li><ks>ledAlarm</ks>: hardware\software component that is on if distance detect by Sonar</li>
<li><ks>Led</ks>: hardware component provided by client . The component has 2 state on/off ,it can be commanded by gpio port.</li>
<li><ks>DLIMIT</ks>: threshold value for turn on\off led.</li>

</ol>

Ambiguity of the requirements: the requirement that the led turns on when the distance is less than DLIMIT implies that if the distance subsequently increases beyond DLIMIT the led stays on. The requirement is interpreted as: the led turns on when the distance is less than DLIMIT and turns off when the distance is greater than DLIMIT.

</div>

<div class="filledbyprovider">
<ks>TEST PLAN</ks>: 
<ol>

<li><ks>Test 1</ks>:start with led off ,  move an object close to sonar ,when object is less than DLIMIT and led is on test is ok</li>

</ol>
</div>

<h2>Problem analysis</h2>
<div class="remark">
<ks>MAIN GOALS</ks>: 
<ol>
<li>identify the main problems involved by the requirements and the most appropriate (software) technologies to adopt</li>
<li>evaluate the <k>abstraction gap</k> and </i>give a <k>quantitative measure of the effort/resources</k> necessary to build the system</li>
<li>define (a <k>model</k> of) the <k>logical architecture</k> of the system</li>
<li>refine the set of <k>functional TestPlan</k></li>
<li>(with reference to <ks>SCRUM</ks>) define a (first) <k>product backlog</k> and a possibile set/sequence of <ks>SPRINT</ks>  </li>
</ol>
 </div>

<div class="filledbyprovider">
<ks>PROBLEM ANALYSIS</ks>: 
<br>
The following table shows the requirements and broken down into architectural dimensions.
Dist is the value read by the radar which is transmitted to the rest of the system.
<br>
<table>
<thead>
  <tr>
    <th>Requirements</th>
    <th>Component</th>
    <th>Structure</th>
    <th>Comunication</th>
    <th>Behaviour</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>RadarGui</td>
    <td>RadarPojo</td>
    <td>PC</td>
    <td>Input Dist</td>
    <td>Show Dist</td>
  </tr>
  <tr>
    <td>LedAlarm</td>
    <td>Sonar HC-SR04</td>
    <td>Rasberry</td>
    <td>Output Dist</td>
    <td>Read Dist</td>
  </tr>
  <tr>
    <td>LedAlarm</td>
    <td>Led</td>
    <td>Rasberry</td>
    <td>Input Dist</td>
    <td>f(Dist) => on\off</td>
  </tr>
</tbody>
</table>
<br>
This makes it clear that there are two logical entities ledAlarm and radarGUI that communicate from ledAlarm to radarGUI.<br>
<br>
<img src="img\LogicArchitecture.RadarSystem.drawio.png" alt="Logical Architecture"  class="center"><br>
<center><b>Logical Architecture</b></center>

<br>
As far as radarGUI is concerned, it is satisfied by an entity that contains radarPojo which receives a message containing the value of Dist is called Radar.<br>
The time between two updates of the Dist value on the radar is TRADAR.<br>
For the ledAlarm side, since for now the sonar and the led can be on the same node, the value of f (Dist) must not leave the node.<br>
To satisfy a property of independence between the radar and the sonar \ led pair it is necessary to add a communication entity with the sonar \ led pair which is called Sonar.<br>
<br>
At this point the abstraction gap is clear: how to read the sonar distance? , how to transmit the distance value? , how to control the LEDs?<br>
Technological problems follow: how to make different technologies interact? , is it possible to reduce the number of technologies used in order to reduce the number of release entities? is it possible to reduce the number of messages? what's the trade-off with code reusability?<br>
From the Sonar entity to the Radar there are no significant abstraction gaps to fill.<br>
<br>
To solve the sonar reading requirement a Sonar.c library has been provided which writes to standard output, this library does not meet the requirement for communicating with the rest of the system.<br>
The problem of reading and communicating implies that a technological solution that satisfies both requirements is preferable.<br>
The designer prefers the use of python with its gpio and mqtt libraries to this library, allowing to satisfy the requirement of reading and communicating with the rest of the system.<br>
The entity that reads and communicates is called SonarRobot.<br>
The time between two sonar readings is called TSONAR.<br>
SonarRobot publishes on mqtt server (P.Dist) and Sonar subscribes (S.Dist).<br>
<br>
A library is provided to control the LEDs which it calls GPIO shell library commands.<br>
The problem of communication and reduction of the number of technologies used implies that also in this case the designer uses python code to be integrated in SonarRobot to control the LEDs and minimize the release files.<br>
At this point the problem arises of choosing between an architecture that favors reusability, more expensive in terms of released entities, or a more monolithic but less expensive approach in terms of released entities.<br>

The designer chooses not to maximize the reusability (NMR) of the code to reduce the released components and the number of messages. The other choice is to have a Led entity that commands via mqtt a python entity (LedRobot) that commands the leds directly with python code or calls the scripts provided , or in alternative led use mqtt to comunicate to PC and command led in one of the previous ways.<br>
The choice, maximum reusability (MR), would imply that LedRobot publishes (P.Led) on the mqtt server and Led subscribes (S.Led).<br>
SonarRobot also manages access to the file system to obtain the DLIMIT value used as a threshold to control the on / off values ​​of the LED.<br>
It should be noted that the choice made is completely consistent with the requirements as neither reusability nor the communication of information regarding the management of the LEDs outside the entities defined in the ledAlarm requirement is required.<br>
The advantage of the choice made is also to have fewer messages exchanged in the system as opposed to the choice of greater reusability.<br>
<br>
<br>
In order to decouple Sonar and Radar, a Controller entity is introduced which requests the Dist value from Sonar and sends the Dist value to Radar.<br>
Since it is preferable to have TSONAR other than TRADAR, as they are different components whose optimal values ​​are to be calibrated during the development phase, the Controller entity must manage the TRADAR update, so it will contain a timer.<br>
Controller asks Sonar for the Dist value which responds with the requested value with TRADAR period, and consequently sends it to Radar.<br>
<br>
FRADAR = 1 / TRADAR<br>
FSONAR = 1 / TSONAR<br>
alpha = messages sent to broker / sonar readings<br>
<br>
Defined NLED the number of times the LED is commanded, the choice made indicates that the number of messages exchanged is: 3 * FRADAR + S.Dist + alpha * 2 * FSONAR, on the contrary the choice with the Led entity is the number of messages traded is: 3 * FRADAR + S.Dist + alpha * 2 * FSONAR + S.Led + 3 * NLED.<br>
<br>
<table>
<thead>
  <tr>
    <th>Architecture</th>
    <th>Number of message</th>
    <th>Number of deployed entity</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>No Max Reusability</td>
    <td>3*FRADAR + S.Dist + alpha*2*FSONAR</td>
    <td>SonarRobot.py + CtxPc</td>
  </tr>
  <tr>
    <td>Max Reusability</td>
    <td>3*FRADAR + S.Dist + alpha*2*FSONAR + S.Led +  3*NLED</td>
    <td>2*sh + Sonar.c + Led + Sonar + CtxPc*</td>
  </tr>
</tbody>
</table>
CtxPc contains the entities to be released on the pc node, with CtxPc * we mean that the MR choice implies a context of minor elements.
<br>
<br>


</div>


<ks>WARNING</ks>: expressions like <i>'we have chosen to ...'</i>, <i>'I decided ...'</i>, etc. are <k>forbidden</k> here. <br/>
Rather, this section should include sentences like
<b><i>'this (aspect of the) problem implies that ...'</i></b> or <i><b>'the usage of this (legacy) component requires that ...'</i></b>, etc.
<br/>


<!-- <h2>Test plans</h2>  -->
<!-- <div class="remark"> -->
<!-- <ks>MAIN GOALS</ks>:   -->
<!-- <ol> -->
<!-- <li>with reference to the <k>logical architecture</k> of the system, -->
<!-- write a program (e.g. by using <ks>JUnit</ks>) that defines the set of <k>functional TestPlans</k> that the software must satisfy. -->
<!-- </li> -->
 
<!-- </ol> -->
 
<!-- </div> -->

<h2>Project</h2> 
<div class="remark">
<ks>MAIN GOALS</ks>: 
<ol>
<li>by starting from the <k>logical architecture</k> of the system, 
define the <k>concrete/k> architecture of the system and the behavior of each component  .</li>

</ol>



</div>
<div class="filledbyprovider">
<ks>PROJECT</ks>: 

<img src="img\ProjectArchitecture.RadarSystem.drawio.png" alt="Project Architecture."  class="center">
<br>

<center><b>Project Architecture</b></center>
<br>
<br>
<img src="img\ProjectArchitecture.AlternativeRadarSystem.drawio.png" alt="Alternative Project Architecture"  class="center">
<br>

<center><b>Alternative Project Architecture</b></center>
<br>
<br>
</div>
<!-- <h2>Testing</h2>  -->
<!-- <div class="remark"> -->
<!-- <ks>MAIN GOALS</ks>:  -->
<!-- <ol> -->
<!-- <li>complete the <k>functional TestPlans</k> according to the project code and execute them.</li> -->
<!-- </ol> -->

<!-- </div> -->

<!-- <h2>Deployment</h2>  -->

<!-- <div class="remark"> -->
<!-- <ks>MAIN GOALS</ks>:  -->
<!-- <ol> -->
<!-- <li> prepare the  software application to run and operate in a specific environment.</li> -->
<!-- </ol> -->
 <!-- </div> -->
<!-- It involves installation, configuration, testing and making changes to optimize the performance of the software.  -->
<!-- It can either be carried out manually or (hopefully) through automated systems. -->




<!-- <h2>Maintenance</h2>  -->
<!-- <div class="remark"> -->
<!-- <ks>MAIN GOALS</ks>:  -->
<!-- <ol> -->
<!-- <li>modify the software product after delivery to correct faults,  -->
<!-- to improve performance or other attributes. </li> -->
<!-- </ol> -->
 <!-- </div> -->
<!-- A common perception of maintenance is that it merely involves fixing defects.  -->
<!-- However, one study indicated that over <tt>80%</tt> of maintenance effort is used for non-corrective actions. -->


<!-- <h1 id="activity">UN QUADRO DI INSIEME (da esperienza 2019/2020)</h1> -->
 


 <!-- <p> -->
<!-- Il nostro obiettivo è costruire software impostando -->
<!-- (in modo 'agile', <em>non water-fall</em>, cioè con possibilità di modifiche dopo un ciclo di sviluppo): -->
<!-- <ol> -->
<!-- <li>l'analisi dei requisiti </li> -->
<!-- <li>l'analisi del problema</li> -->
<!-- <li>la progettazione e lo sviluppo della applicazione</li> -->
<!-- <li>il deployment (in docker) </li> -->
<!-- </ol> -->

<!-- L'obiettivo finale è partire fin dalla analisi dei requisiti con la definizione di MODELLI -->
<!-- ESEGUIBILI e PIANI DI TESTING che si estendono/modificano nelle varie fasi. -->
<!-- </p><p> -->
<!-- Per questo fine può essere opportuno definire un 'progetto preliminare' da inserire in <em>UN SOLO -->
<!-- workspace</em> (denominato ad esempio  <ks>xxxISS2021</ks>, con <ks>xxx</ks>=nome del Team). -->
<!-- In questo workspace andranno inseriti altri progetti, da quando inizia la fase 3. -->
<!-- </p><p> -->
<!-- L'analisi del problema dovrebbe produrre un modello che esprime la architettura logica -->
<!-- del sistema e pone in luce l'<em>Abstraction Gap</em> (se esiste) rispetto alle tecnologie di riferimento -->
<!-- per la implementazione (per noi Java/Kotlin). -->
<!-- </p><p> -->
<!-- Per applicazioni relative a <em>sistemi distribuiti eterogenei</em>, partiamo -->
<!-- dalla constatazione che esiste 'di base' un Abstraction Gap rispetto a Java/Kotlin  -->
<!-- che ci porta  a definire e realizzare un insieme di layer di supporto a livelli  di astrazione -->
<!-- crescente che culminerà della definizione del -->
<!-- <em>metamodello QAK</em> e della relativa piattaforma di supporto (Plugin eclipse). -->
<!-- </p><p> -->
<!-- Va sottolineato che ogni specifico problema di norma può indurre un analista/progettista a individuare altri  -->
<!-- Abstraction Gap rispetto al metamodello <tt>QAK</tt> stesso, in accordo a un 'processo evolutivo' -->
<!-- non predicibile e senza fine. -->
<!-- </p> -->

<!-- <h2>Lo sviluppo 'agile'</h2> -->
<!-- <p> -->
<!-- L'articolazione dello sviluppo in SPRINT (Scrum) inizia dopo l'analisi del problema, -->
<!-- e si basa sulla opportunità di affrontare i requisiti in modo incrementale. -->
<!-- </p><p> -->
<!-- Di solito seguiamo un approccio <em>'dal semplice al complesso'</em>, -->
<!-- introducendo un opportuno insieme di ASSUNZIONI. Ma ovviamente questo non è -->
<!-- l'unico criterio possibile nè quello sempre più opportuno. -->
<!-- </p><p> -->
<!-- Ad esempio il primo SPRINT della applicazione del -->
<!-- <a href="http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/TemaFinaleBo20.html"  -->
<!-- target="web">TemaFinaleBo20.html</a> -->

<!-- può essere volto alla costruzione di un prototipo -->
<!-- relativo al caso di un solo cliente che entra, ordina, consuma ed esce (senza incorrere -->
<!-- nel problema 'maxstaytime' ).  -->
<!-- </p><p> -->
<!-- Una volta arrivati al <em>'done'</em> (terminologia SCRUM) di uno SPRINT, per decidere come impostare il successivo SPRINT  -->
<!-- vanno inooltre sempre considerati anche aspetti di tipo economico-organizzativo,  -->
<!-- in modo da assicurare che il processo di sviluppo si possa compiere nei tempi stabiliti e con costi contenuti. -->
<!-- </p><p> -->
<!-- Ogni SPRINT dovrebbe includere opportuni test   (a partire dai <i>Piani di Testing</i> già delineati/definiti nella -->
<!-- fase di analisi dei requisiti) da eseguire al termine dello SPRINT.  -->
<!-- Inoltre vanno considerate le fasi di <em>SPRINT-review</em> -->
<!-- e <em>SPRINT-retrospective</em> che potrebbero essere condotte dopo un meeting con il committente -->
<!-- (cioè con il docente). -->
<!-- </p><p> -->
<!-- Dunque il <b>numero e le finalità degli SPRINT sono definiti dal Team</b> di sviluppo, dopo le interazioni -->
<!-- suddette con con il committente. -->
<!-- </p><p> -->
<!-- Come detto, ogni SPRINT andrebbe inserito in un apposito nuovo progetto nel workspace -->
<!-- <ks>xxxISS2020</ks> e salvato in un apposito GIT repo, il cui indirizzo  viene inviato al committente -->
<!-- al momento della consegna. -->
<!-- </p> -->

<!-- <h2>History e non documentazione ex-post</h2> -->
<!-- <p> -->
<!-- E' importante che un progetto relativo ad uno SPRINT contenga un folder (<ks>userDocs</ks>) -->
<!-- che include un documento organizzato secondo il template HTML proposto in questo documento. -->
 
<!-- </p><p> -->
<!-- Nel documento vanno riportati, per ogni sezione, i PUNTI-CHIAVE -->
<!-- (come se fosse un presentazione da illustrare in un meeting), facendo riferimento, -->
<!-- se si ritiene opportuno, ad altri documenti per  descrizioni/discussioni più dettagliate. -->

<!-- </p><p> -->
<!-- Ovviamente lo <tt>SPRINT/N</tt> potrà fare riferimento con opportuni link - se e' il caso - a documenti dello   -->
<!-- <tt>SPRINT/N-1</tt> o precedenti. -->
<!-- </p>  -->


<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
By studentName email: ugo.marchesini@studio.unibo.it  
<!-- <img src="./img/emiglio.png" alt="mbot" width="15%" height="15%"> -->
</div> 
</body>
</html>